use anchor_lang::prelude::*;
// pub mod state;

// pub use error:: {ErrorCode, PeriodError};
// pub use instructions::*;
// pub use state::*;

use anchor_lang::solana_program::sysvar::clock::Clock;
use std::str::FromStr;

use {
    anchor_lang::prelude::*,
    anchor_lang::solana_program::pubkey::Pubkey,
    anchor_spl::{
        metadata::{
            create_metadata_accounts_v3,
            mpl_token_metadata::types::DataV2,
            CreateMetadataAccountsV3,
        },
        token::{mint_to, transfer, MintTo, Transfer},
    },
};


declare_id!("6Py5RKvhAAbqWcHjavqkNdtMaMm6TDLGovDEynNzFPX9");

#[program]
pub mod nft_platform {
    use anchor_spl::metadata::mpl_token_metadata::types::Creator;

    use super::*;
    
    pub fn initialize_counter(ctx: Context<InitializeCounter>) -> Result<()> {
        let counter: &mut Account<'_, Counter> = &mut ctx.accounts.counter;
    
        counter.count = 0; // Start the global counter at 0
        Ok(())
    }
    
    pub fn purchase(ctx: Context<Purchase>, buy_number: u8) -> Result<()> {
        msg!("Purchase start");
    
        const NFT_PRICE: u64 = 555_000_000;
        let total_usdc: u64 = buy_number as u64 * NFT_PRICE;
    
        // Ensure the buyer has enough USDC balance
        let user_usdc_balance: u64 = ctx.accounts.user_usdc_account.amount;
        if user_usdc_balance < total_usdc {
            return Err(ErrorCode::InsufficientFunds.into());
        }

        // Calculate distribution amounts
        let amount_to_address1: u64 = total_usdc * 75 / 100;
        let amount_to_address2: u64 = total_usdc - amount_to_address1;

        msg!("Purchase first address");
        // Transfer 75% to address1

        let cpi_accounts_1: Transfer<'info> = Transfer {
            from: ctx.accounts.user_usdc_account.to_account_info(),
            to: ctx.accounts.purchase1_usdc_account.to_account_info(),
            authority: ctx.accounts.buyer.to_account_info(), // Use buyer as the authority
        }

        let cpi_ctx_1: CpiContext<'_, '_, '_, 'info, Transfer> =
        CpiContext::new(ctx.accounts.token_program.to_account_info(), cpi_accounts_1);
        transfer(cpi_ctx_1, amount_to_address1)?;

        msg!("Purchase second address");
        // Transfer 25% to address2

        let cpi_accounts_2: Transfer<'info> = Transfer {
            from: ctx.accounts.user_usdc_account.to_account_info(),
            to: ctx.accounts.purchase2_usdc_account.to_account_info(),
            authority: ctx.accounts.buyer.to_account_info(), // Use buyer as the authority
        }

        let cpi_ctx_2: CpiContext<'_, '_, '_, 'info, Transfer> =
        CpiContext::new(ctx.accounts.token_program.to_account_info(), cpi_accounts_2);
        transfer(cpi_ctx_2, amount_to_address2)?;
        Ok(())
    }

    // Function to mint multiple NFTs
    pub fn mint_nft(
        ctx: Context<NFTMint>,
        nft_name: String,
        nft_symbol: String,
        nft_uri: String,
) -> Result<()> {
    msg!("start nft mint");
    let counter = &mut ctx.accounts.counter;
    let time_account = &mut ctx.accounts.time_account;

    // Increment the counter atomically
    let current_count: u64 = counter.count;
    let buy_start_time: i64 = time_account.buy_start_time;
    let reveal_start_time: i64 = time_account.reveal_start_time;

    let clock: Clock = Clock::get()?;
let current_timestamp: i64 = clock.unix_timestamp;
if buy_start_time > current_timestamp || current_timestamp > reveal_start_time {
    return Err(error!(PeriodError::BuyPeriodExceed));
}

if current_count > 8888 {
    return Err(error!(ErrorCode::MintAmountExceed));
}

counter.count += 1;

// Generate a unique name for the NFT (e.g., "Ticket #1", "Ticket #2")
let unique_name: String = format!("{} NFT #{}", nft_name, current_count);

msg!("Minting Token");

mint_to(
    CpiContext::new(
        ctx.accounts.token_program.to_account_info(),
        MintTo {
            mint: ctx.accounts.mint_account.to_account_info(),
            to: ctx.accounts.associated_token_account.to_account_info(),
            authority: ctx.accounts.payer.to_account_info(),
        },
    ),
    1,
)?;

msg!("Creating metadata account");

create_metadata_accounts_v3(
    CpiContext::new(
        ctx.accounts.token_metadata_program.to_account_info(),
        CreateMetadataAccountsV3 {
            metadata: ctx.accounts.metadata_account.to_account_info(),
            mint: ctx.accounts.mint_account.to_account_info(),
            mint_authority: ctx.accounts.payer.to_account_info(),
            update_authority: ctx.accounts.payer.to_account_info(),
            payer: ctx.accounts.payer.to_account_info(),
            system_program: ctx.accounts.system_program.to_account_info(),
            rent: ctx.accounts.rent.to_account_info(),
        },
    ),
)?;

create_metadata_accounts_v3(
    CpiContext::new(
        ctx.accounts.token_metadata_program.to_account_info(),
        CreateMetadataAccountsV3 {
            metadata: ctx.accounts.metadata_account.to_account_info(),
            mint: ctx.accounts.mint_account.to_account_info(),
            mint_authority: ctx.accounts.payer.to_account_info(),
            update_authority: ctx.accounts.payer.to_account_info(),
            payer: ctx.accounts.payer.to_account_info(),
            system_program: ctx.accounts.system_program.to_account_info(),
            rent: ctx.accounts.rent.to_account_info(),
        },
    ),
DataV2 {
    name: unique_name,
    symbol: nft_symbol,
    uri: nft_uri,
    seller_fee_basis_points: 0,
    creators: None,
    collection: None,
    uses: None,
},
false, // Is mutable
true, // Update authority is signer
None, // Collection details Â  
)?;

msg!("NFT minted successfully.");

Ok(())

}


    pub fn initialize_time(ctx: Context<InitializeTime>, bump: u8) -> Result<()> {
        let clock: Clock = Clock::get()?;
        let current_timestamp: i64 = clock.unix_timestamp;
    
        let buy_start_time: i64 = current_timestamp;
        let reveal_start_time: i64 = buy_start_time + (60 * 24 * 60 * 60); // 60 days in seconds
        let claim_start_time: i64 = reveal_start_time + (120 * 24 * 60 * 60); // 120 days in seconds
        let end_time: i64 = claim_start_time + (240 * 24 * 60 * 60); // 240 days in seconds
    
        let time_account = &mut ctx.accounts.time_account;
        time_account.buy_start_time = buy_start_time;
        time_account.reveal_start_time = reveal_start_time;
        time_account.claim_start_time = claim_start_time;
        time_account.end_time = end_time;
        time_account.bump = bump;
        Ok(())
    }
    
    pub fn reveal(ctx: Context<Reveal>, random_number: u16) -> Result<()> {
        let nft_random_number = &mut ctx.accounts.nft_random_number;
        let time_account = &mut ctx.accounts.time_account;
    
        let reveal_start_time: i64 = time_account.reveal_start_time;
        let claim_start_time: i64 = time_account.claim_start_time;
    
        let clock: Clock = Clock::get()?;
        let current_timestamp: i64 = clock.unix_timestamp;
        if reveal_start_time > current_timestamp || current_timestamp > claim_start_time {
            return Err(error!(PeriodError::RevealPeriodExceed));
        }
    
        nft_random_number.is_purchase = true;
        nft_random_number.random_number = random_number;
        Ok(())
    }
    
}


